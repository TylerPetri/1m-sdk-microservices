# Design Overview

This repository is a production-style Go microservices baseline.  
It optimizes for **clarity, consistency, and operational correctness** over framework cleverness.

The intent is that new services can be added without copy/paste drift and that core behaviors
(logging, health, config, shutdown) are uniform across the fleet.

---

## Where to start reading

If you’re reviewing this repo:

1. `internal/platform/` — shared service primitives
2. `cmd/<service>/main.go` — service boot pattern
3. `proto/` + `buf.yaml` — API boundaries and generation
4. `sqlc.yaml` + `migrations/` — data access contract
5. CI workflow / `make verify` — enforced guarantees

Everything else fans out from these.

---

## Service architecture

Each service follows the same structure:

```text
cmd/<service>/
  main.go        # wiring only (no business logic)

internal/
  platform/      # shared boot + runtime concerns
  <domain>/      # service-specific logic
```

### Service shape

All services:

- Expose a **primary gRPC API**
- Optionally expose an **HTTP surface** via `grpc-gateway`
- Expose an **admin port** for health and metrics

There is no shared “god service” and no global runtime state.

---

## Platform layer (shared)

`internal/platform/` centralizes cross-cutting concerns:

- Structured logging
- Environment-driven configuration
- Graceful shutdown
- Health and readiness checks
- Middleware / interceptors
- Metrics and tracing hooks

This avoids re-implementing “service basics” in every `main.go`.

**Policy:** service `main.go` files should only *compose* platform pieces, not define them.

---

## API boundaries

Public APIs are defined in `proto/` and generated via **Buf**.

- gRPC is the internal service boundary
- HTTP is treated as an edge concern (`grpc-gateway`)
- No handwritten DTOs or ad-hoc JSON structs

CI enforces:

- Protobuf linting
- Breaking-change detection against the main branch

This keeps API evolution explicit and reviewable.

---

## Data access

- Postgres via `pgxpool`
- Queries generated by `sqlc`
- No ORMs or runtime query builders

Migrations are:

- Versioned
- Run deterministically
- Smoke-tested in CI against a clean database

Generated code is treated as a **checked-in artifact** and verified by CI to prevent drift between developers.

---

## Configuration & secrets

- Configuration is environment-based
- No secrets are committed to the repository
- Defaults exist for local development only

This mirrors typical containerized production environments.

---

## Operational posture

Each service exposes:

- `/livez` — process health
- `/readyz` — dependency readiness
- `/metrics` — Prometheus-compatible metrics

The repository includes Docker Compose profiles to run:

- Services
- Database
- Observability stack (Prometheus / Grafana / tracing)

This reflects a realistic “day-one production” setup.

---

## Adding a new service (intended workflow)

1. Define the API in `proto/<service>/`
2. Run `make generate`
3. Create `cmd/<service>/main.go` using the platform boot pattern
4. Add the service to Docker Compose
5. Add migrations (if needed)
6. CI enforces the rest

No service should require bespoke wiring or custom boot logic.

---

## Non-goals

This repository intentionally does **not** include:

- Service meshes
- Distributed transactions
- Complex authentication flows
- Premature caching layers

These are added only when justified by real requirements.

---

## Design philosophy

**Prefer:**

- Boring defaults
- Explicit boundaries
- Policy enforced by tooling
- Small, reviewable diffs

**Avoid:**

- Hidden magic
- Framework lock-in
- Implicit runtime behavior
